function [Q_results] = bloodVolumeRate(mask, name, v_RMS, M0_ff_video, xy_barycenter)

ToolBox = getGlobalToolBox;

if ~isfolder(fullfile(ToolBox.path_png, 'volumeRate'))
    mkdir(ToolBox.path_png, 'volumeRate')
    mkdir(ToolBox.path_eps, 'volumeRate')
end

params = ToolBox.getParams;

initial = name(1);

[numX, numY, numFrames] = size(v_RMS);
x_barycenter = xy_barycenter(1);
y_barycenter = xy_barycenter(2);
t = linspace(0, numFrames * ToolBox.stride / ToolBox.fs / 1000, numFrames);
M0_ff_video = rescale(M0_ff_video);
M0_ff_img = rescale(mean(M0_ff_video, 3));

%% 1. Mask Sectionning for all circles

% for the all circles output
tic
numCircles = params.json.BloodVolumeRateAnalysis.NumberOfCircles;
r1 = params.json.SizeOfField.SmallRadiusRatio;
r2 = params.json.SizeOfField.BigRadiusRatio;
maskSectionCircles = zeros(numX, numY, numCircles);

dr = (r2 - r1) / numCircles;

if strcmp(name, 'Artery')
    createMaskSection(ToolBox, M0_ff_img, r1, r2, xy_barycenter, sprintf('mask%s_all_sections', name), mask);
else
    createMaskSection(ToolBox, M0_ff_img, r1, r2, xy_barycenter, sprintf('mask%s_all_sections', name), [], mask);
end

parfor circleIdx = 1:numCircles
    r_in = r1 + (circleIdx - 1) * dr;
    r_out = r_in + dr;
    maskSectionCircles(:, :, circleIdx) = diskMask(numX, numY, r_in, r_out, center = [x_barycenter / numX, y_barycenter / numY]);

    % save mask image
    if strcmp(name, 'Artery')
        createMaskSection(ToolBox, M0_ff_img, r_in, r_out, xy_barycenter, sprintf('mask%s_section_circle_%d', name, circleIdx), mask);
    else
        createMaskSection(ToolBox, M0_ff_img, r_in, r_out, xy_barycenter, sprintf('mask%s_section_circle_%d', name, circleIdx), [], mask);
    end
end

fprintf("    1. Mask Sectionning for all circles (%s) output took %ds\n", name, round(toc))

%% 2. Properties of the sections for all circles output

tic

locs = cell(numCircles, 1);
numSections = zeros(1, numCircles);

parfor circleIdx = 1:numCircles
    maskSection = logical(maskSectionCircles(:, :, circleIdx) .* mask);
    s = regionprops(maskSection, 'centroid');
    locs{circleIdx} = round(cat(1, s.Centroid));
    numSections(circleIdx) = size(locs{circleIdx}, 1);
end

fprintf("    2. Initialisation of the sections for all circles (%s) took %ds\n", name, round(toc))

%% 3. Cross-sections analysis for all circles output

tic

if ~isfolder(fullfile(ToolBox.path_png, 'volumeRate', 'crossSection'))
    mkdir(fullfile(ToolBox.path_png, 'volumeRate'), 'crossSection')
    mkdir(fullfile(ToolBox.path_png, 'volumeRate'), 'projection')
end

% 3.0. Does the cross Section Analysis circle by circle
% To inspect the code of crossSectionAnalysis remember to disable the
% parallel loops

[Q_cell, dQ_cell, v_cell, dv_cell, v_profiles_cell, dv_profiles_cell, A_cell, D_cell, dD_cell, mask_mat, subImg_cell] = crossSectionAnalysisAllRad(numSections, locs, mask, v_RMS, initial);

% 3.1. Transform the cell objects generated by crossSectionAnalysisAllRad
% to arrays for the following functions
[area_mat, Q_mat, dQ_mat] = reshapeSections(numFrames, numSections, A_cell, Q_cell, dQ_cell);

% 3.2. Creates the csv files for post processing outside Eyeflow

plot2csvForAllRadSection(t, Q_cell, dQ_cell, Q_mat, dQ_mat, initial)

topvel2csv(t, v_cell, dv_cell, initial);

Q_results.numSections = numSections;
Q_results.locs = locs;
Q_results.v_cell = v_cell;
Q_results.v_profiles_cell = v_profiles_cell;
Q_results.dv_profiles_cell = dv_profiles_cell;
Q_results.D_cell = D_cell;
Q_results.dD_cell = dD_cell;
Q_results.mask_mat = mask_mat;
Q_results.subImg_cell = subImg_cell;
Q_results.area_mat = area_mat;
Q_results.Q_mat = Q_mat;
Q_results.dQ_mat = dQ_mat;

fprintf("    3. Cross-sections analysis for all circles (%s) output took %ds\n", name, round(toc))

end
