function [Q_results] = crossSectionsAnalysis(mask, vesselName, v_RMS, M0_ff_video, xy_barycenter)

ToolBox = getGlobalToolBox;

if ~isfolder(fullfile(ToolBox.path_png, 'crossSectionsAnalysis'))
    mkdir(ToolBox.path_png, 'crossSectionsAnalysis')
    mkdir(ToolBox.path_eps, 'crossSectionsAnalysis')
end

params = ToolBox.getParams;

initial = vesselName(1);

[numX, numY, numFrames] = size(v_RMS);
x_barycenter = xy_barycenter(1);
y_barycenter = xy_barycenter(2);
t = linspace(0, numFrames * ToolBox.stride / ToolBox.fs / 1000, numFrames);
M0_ff_video = rescale(M0_ff_video);
M0_ff_img = rescale(mean(M0_ff_video, 3));

%% 1. Mask Sectionning for all circles

% for the all circles output
tic
numCircles = params.json.CrossSectionsAnalysis.NumberOfCircles;
r1 = params.json.SizeOfField.SmallRadiusRatio;
r2 = params.json.SizeOfField.BigRadiusRatio;
dr = (r2 - r1) / numCircles;
maskSectionCircles = zeros(numX, numY, numCircles);

if strcmp(vesselName, 'Artery')
    createMaskSection(ToolBox, M0_ff_img, r1, r2, xy_barycenter, sprintf('mask%s_all_sections', vesselName), mask);
else
    createMaskSection(ToolBox, M0_ff_img, r1, r2, xy_barycenter, sprintf('mask%s_all_sections', vesselName), [], mask);
end

parfor circleIdx = 1:numCircles
    r_in = r1 + (circleIdx - 1) * dr;
    r_out = r_in + dr;
    maskSectionCircles(:, :, circleIdx) = diskMask(numX, numY, r_in, r_out, center = [x_barycenter / numX, y_barycenter / numY]);

    % save mask image
    if strcmp(vesselName, 'Artery')
        createMaskSection(ToolBox, M0_ff_img, r_in, r_out, xy_barycenter, sprintf('mask%s_section_circle_%d', vesselName, circleIdx), mask);
    else
        createMaskSection(ToolBox, M0_ff_img, r_in, r_out, xy_barycenter, sprintf('mask%s_section_circle_%d', vesselName, circleIdx), [], mask);
    end

end

fprintf("    1. Mask Sectionning for all circles (%s) output took %ds\n", vesselName, round(toc))

%% 2. Properties of the sections for all circles output

tic

locs = cell(numCircles, 1);
numSections = zeros(1, numCircles);

parfor circleIdx = 1:numCircles
    maskSection = logical(maskSectionCircles(:, :, circleIdx) .* mask);
    s = regionprops(maskSection, 'centroid');
    locs{circleIdx} = round(cat(1, s.Centroid));
    numSections(circleIdx) = size(locs{circleIdx}, 1);
end

fprintf("    2. Initialisation of the sections for all circles (%s) took %ds\n", vesselName, round(toc))

%% 3. Cross-sections analysis for all circles output

tic

if ~isfolder(fullfile(ToolBox.path_png, 'crossSectionsAnalysis', 'crossSection'))
    mkdir(fullfile(ToolBox.path_png, 'crossSectionsAnalysis'), 'crossSection')
end

if ~isfolder(fullfile(ToolBox.path_png, 'crossSectionsAnalysis', 'profiles'))
    mkdir(fullfile(ToolBox.path_png, 'crossSectionsAnalysis'), 'profiles')
end

% Initialisation of the cells for arteries
Q_cell = cell(1, numCircles); % Average volume rate
dQ_cell = cell(1, numCircles); % Standard deviation of volume rate
v_cell = cell(1, numCircles); % Top velocity
dv_cell = cell(1, numCircles); % Standard deviation of velocity
v_profiles_cell = cell(1, numCircles); % Top velocity
dv_profiles_cell = cell(1, numCircles); % Standard deviation of velocity
A_cell = cell(1, numCircles); % Cross-sectional area
D_cell = cell(1, numCircles); % Cross-section width
dD_cell = cell(1, numCircles); % Standard deviation of cross-section width
mask_mat = zeros(numX, numY, numCircles); % Cross-section mask
rejected_mask = zeros(numX, numY, 3); % Cross-section mask
subImg_cell = cell(1, numCircles); % Sub-images of vessels

% Cross-Section Analysis of the arteries
parfor c_idx = 1:numCircles
    % Call crossSectionAnalysis2
    circleName = sprintf('C%d_%s', c_idx, initial);
    [results] = crossSectionAnalysis2(ToolBox, locs{c_idx}, mask, v_RMS, circleName);

    % Map outputs to variables
    v_cell{c_idx} = results.v;
    dv_cell{c_idx} = results.dv;
    v_profiles_cell{c_idx} = results.v_profiles;
    dv_profiles_cell{c_idx} = results.dv_profiles;
    Q_cell{c_idx} = results.Q;
    dQ_cell{c_idx} = results.dQ;

    A_cell{c_idx} = results.A;
    D_cell{c_idx} = results.D;
    dD_cell{c_idx} = results.dD;

    mask_mat(:, :, c_idx) = results.crossSectionMask;
    rejected_mask = results.rejected_masks + rejected_mask;
    subImg_cell{c_idx} = results.subImg_cell;
end

try

    if params.json.CrossSectionsAnalysis.sectionMontage
        sectionMontage(subImg_cell, numSections, vesselName)
    end

catch ME
    MEdisp(ME, ToolBox.path_dir)
end

imwrite(rejected_mask, fullfile(ToolBox.path_png, 'crossSectionsAnalysis', sprintf("%s_rejected_masks_%s.png", ToolBox.main_foldername, vesselName)))

% 3.1. Transform the cell objects generated by crossSectionAnalysisAllRad
% to arrays for the following functions
[area_mat, Q_mat, dQ_mat] = reshapeSections(numFrames, numSections, A_cell, Q_cell, dQ_cell);

% 3.2. Creates the csv files for post processing outside Eyeflow

plot2csvForAllRadSection(t, Q_cell, dQ_cell, Q_mat, dQ_mat, initial)

topvel2csv(t, v_cell, dv_cell, initial);

Q_results.numSections = numSections;
Q_results.locs = locs;
Q_results.v_cell = v_cell;
Q_results.v_profiles_cell = v_profiles_cell;
Q_results.dv_profiles_cell = dv_profiles_cell;
Q_results.D_cell = D_cell;
Q_results.dD_cell = dD_cell;
Q_results.mask_mat = mask_mat;
Q_results.area_mat = area_mat;
Q_results.Q_cell = Q_cell;
Q_results.Q_mat = Q_mat;
Q_results.dQ_mat = dQ_mat;

fprintf("    3. Cross-sections analysis for all circles (%s) output took %ds\n", vesselName, round(toc))

end
